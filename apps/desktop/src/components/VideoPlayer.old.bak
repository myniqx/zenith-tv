import { useRef, useState, useEffect } from 'react';
import { usePlayerStore } from '@zenith-tv/ui/stores/player';
import { PlayerControls } from './PlayerControls';
import { useContentStore } from '../stores/content';
import { useSettingsStore } from '../stores/settings';
import { Button } from '@zenith-tv/ui/button';
import { Loader2, AlertTriangle, Film } from 'lucide-react';
import { useVlcPlayer } from '../hooks/useVlcPlayer';
import { WatchableObject } from '@/m3u/watchable';

export function VideoPlayer() {
  const { playerBackend } = useSettingsStore();

  // Determine which player to use
  const vlc = useVlcPlayer();
  const shouldUseVlc = playerBackend === 'vlc' ||
    (playerBackend === 'auto' && vlc.isAvailable);

  if (shouldUseVlc && vlc.isAvailable) {
    return <VlcVideoPlayerImpl vlc={vlc} />;
  }

  return <Html5VideoPlayer />;
}

// VLC Player Implementation
function VlcVideoPlayerImpl({ vlc }: { vlc: ReturnType<typeof useVlcPlayer> }) {
  const containerRef = useRef<HTMLDivElement>(null);
  const videoAreaRef = useRef<HTMLDivElement>(null);
  const [showControls, setShowControls] = useState(true);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const hideControlsTimeoutRef = useRef<NodeJS.Timeout>(null);
  const resizeObserverRef = useRef<ResizeObserver | null>(null);

  const {
    currentItem,
    state,
    setState,
    updatePosition,
    updateDuration,
    play: playItem,
  } = usePlayerStore();

  const { getNextEpisode, saveWatchProgress } = useContentStore();
  const { autoPlayNext, defaultVolume } = useSettingsStore();

  // Track if child window has been created (local state since removed from hook)
  const [isChildWindowCreated, setIsChildWindowCreated] = useState(false);
  const isCreatingWindowRef = useRef(false);

  // Track retry count to prevent infinite loops
  const retryCountRef = useRef(0);

  // Reset retry count when item changes
  useEffect(() => {
    retryCountRef.current = 0;
  }, [currentItem?.Url]);

  // Create child window and start playback - combined to ensure correct order
  useEffect(() => {
    if (!vlc.isInitialized || !currentItem || !videoAreaRef.current) {
      return;
    }

    // Prevent infinite loops if window creation fails repeatedly
    if (retryCountRef.current >= 3) {
      console.error('[VLC VideoPlayer] Max retries reached for window creation/playback');
      setState('error');
      return;
    }

    const setupAndPlay = async () => {
      const element = videoAreaRef.current;
      if (!element) return;

      // Step 1: Create child window if not already created
      if (!isChildWindowCreated && !isCreatingWindowRef.current) {
        isCreatingWindowRef.current = true;

        const rect = element.getBoundingClientRect();
        const bounds = {
          x: Math.round(rect.x),
          y: Math.round(rect.y),
          width: Math.round(rect.width),
          height: Math.round(rect.height),
        };

        if (bounds.width <= 0 || bounds.height <= 0) {
          console.log('[VLC VideoPlayer] Invalid bounds, skipping');
          isCreatingWindowRef.current = false;
          return;
        }

        console.log('[VLC VideoPlayer] Step 1: Creating child window with bounds:', bounds);

        try {
          // Use unified window API
          const success = await vlc.window({ resize: bounds, visible: true });
          console.log('[VLC VideoPlayer] Child window creation result:', success);

          if (success) {
            setIsChildWindowCreated(true);
          } else {
            console.error('[VLC VideoPlayer] Failed to create child window');
            isCreatingWindowRef.current = false;
            retryCountRef.current++;
            return;
          }
        } catch (err) {
          console.error('[VLC VideoPlayer] Exception creating child window:', err);
          isCreatingWindowRef.current = false;
          retryCountRef.current++;
          return;
        }

        isCreatingWindowRef.current = false;

        // Small delay after window creation before playing
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      // Step 2: Start playback AFTER child window is ready
      if (isChildWindowCreated) {
        console.log('[VLC VideoPlayer] Step 2: Starting playback for:', currentItem.Url);
        setState('loading');

        try {
          await vlc.audio({ volume: defaultVolume * 100 });
          await vlc.open(currentItem.Url);
          await vlc.playback({ action: 'play' });
          console.log('[VLC VideoPlayer] Playback started successfully');

          // Success - reset retries
          retryCountRef.current = 0;

          // Handle resume from watch progress
          if (currentItem.userData?.watchProgress && currentItem.userData.watchProgress > 0) {
            const progressPercent = currentItem.userData.watchProgress;
            setTimeout(async () => {
              if (vlc.duration > 0) {
                const position = (progressPercent / 100) * vlc.duration;
                if (position > 0 && position < vlc.duration - 10000) {
                  await vlc.playback({ time: position });
                }
              }
            }, 1000);
          }
        } catch (err) {
          console.error('[VLC VideoPlayer] Playback error:', err);
          setState('error');
          retryCountRef.current++;
        }
      }
    };

    // Small delay to ensure layout is complete
    const timeoutId = setTimeout(setupAndPlay, 200);

    return () => {
      clearTimeout(timeoutId);
      // Stop playback when URL changes
      // vlc.stop(); // Don't stop here, let the unmount handler or next play handle it
    };
  }, [vlc.isInitialized, currentItem?.Url, isChildWindowCreated]); // Trigger on URL change or window creation state change

  // Handle resize - update bounds when container size changes
  useEffect(() => {
    if (!vlc.isInitialized || !videoAreaRef.current || !isChildWindowCreated) {
      return;
    }

    const updateBounds = async () => {
      const element = videoAreaRef.current;
      if (!element || !isChildWindowCreated) return;

      const rect = element.getBoundingClientRect();
      const bounds = {
        x: Math.round(rect.x),
        y: Math.round(rect.y),
        width: Math.round(rect.width),
        height: Math.round(rect.height),
      };

      if (bounds.width > 0 && bounds.height > 0) {
        await vlc.window({ resize: bounds });
      }
    };

    resizeObserverRef.current = new ResizeObserver(() => {
      updateBounds();
    });

    resizeObserverRef.current.observe(videoAreaRef.current);

    window.addEventListener('resize', updateBounds);

    return () => {
      if (resizeObserverRef.current) {
        resizeObserverRef.current.disconnect();
      }
      window.removeEventListener('resize', updateBounds);
    };
  }, [vlc.isInitialized, isChildWindowCreated]);

  // Cleanup child window only when component unmounts
  useEffect(() => {
    return () => {
      console.log('[VLC VideoPlayer] Stopping playback on unmount');
      if (vlc.isAvailable) {
        vlc.playback({ action: 'stop' }).catch(err => {
          console.error('[VLC VideoPlayer] Failed to stop on unmount:', err);
        });
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Sync VLC state with player store
  useEffect(() => {
    if (!vlc.isInitialized) return;

    const stateMap: Record<string, typeof state> = {
      idle: 'idle',
      opening: 'loading',
      buffering: 'buffering',
      playing: 'playing',
      paused: 'paused',
      stopped: 'idle',
      ended: 'idle',
      error: 'error',
      unknown: 'idle',
    };

    const mappedState = stateMap[vlc.playerState] || 'idle';
    if (mappedState !== state) {
      setState(mappedState);
    }
  }, [vlc.playerState, vlc.isInitialized, state, setState]);

  // Sync time updates
  useEffect(() => {
    if (vlc.isInitialized && vlc.time > 0) {
      updatePosition(vlc.time / 1000);
    }
  }, [vlc.time, vlc.isInitialized, updatePosition]);

  // Sync duration
  useEffect(() => {
    if (vlc.isInitialized && vlc.duration > 0) {
      updateDuration(vlc.duration / 1000);
    }
  }, [vlc.duration, vlc.isInitialized, updateDuration]);

  // Handle end of playback
  useEffect(() => {
    if (vlc.playerState === 'ended' && autoPlayNext && currentItem) {
      const nextEpisode = getNextEpisode(currentItem);
      if (nextEpisode) {
        setTimeout(() => playItem(nextEpisode), 500);
      }
    }
  }, [vlc.playerState, autoPlayNext, currentItem, getNextEpisode, playItem]);

  // Auto-save watch progress
  useEffect(() => {
    if (!vlc.isInitialized || !currentItem || vlc.playerState !== 'playing') return;

    const saveInterval = setInterval(async () => {
      if (vlc.duration > 0) {
        try {
          await saveWatchProgress(
            currentItem as WatchableObject,
            vlc.time / 1000,
            vlc.duration / 1000
          );
        } catch (error) {
          console.error('Failed to save watch progress:', error);
        }
      }
    }, 10000);

    return () => {
      clearInterval(saveInterval);
      if (vlc.duration > 0) {
        saveWatchProgress(currentItem as WatchableObject, vlc.time / 1000, vlc.duration / 1000)
          .catch(err => console.error('Failed to save watch progress on unmount:', err));
      }
    };
  }, [currentItem, vlc.playerState, vlc.time, vlc.duration, vlc.isInitialized, saveWatchProgress]);

  // Auto-hide controls
  useEffect(() => {
    if (showControls && vlc.playerState === 'playing') {
      if (hideControlsTimeoutRef.current) {
        clearTimeout(hideControlsTimeoutRef.current);
      }
      hideControlsTimeoutRef.current = setTimeout(() => {
        setShowControls(false);
      }, 3000);
    }

    return () => {
      if (hideControlsTimeoutRef.current) {
        clearTimeout(hideControlsTimeoutRef.current);
      }
    };
  }, [showControls, vlc.playerState]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = async (e: KeyboardEvent) => {
      if (!vlc.isInitialized) return;

      switch (e.key) {
        case ' ':
        case 'k':
          e.preventDefault();
          if (vlc.playerState === 'playing') {
            await vlc.playback({ action: 'pause' });
          } else if (vlc.playerState === 'stopped' || vlc.playerState === 'ended' || vlc.playerState === 'idle') {
            // If stopped/ended/idle, need to re-open and play
            if (currentItem) {
              await vlc.open(currentItem.Url);
              await vlc.playback({ action: 'play' });
            }
          } else {
            // Paused state - just resume
            await vlc.playback({ action: 'resume' });
          }
          break;
        case 'ArrowLeft':
          e.preventDefault();
          await vlc.playback({ time: Math.max(0, vlc.time - 10000) });
          break;
        case 'ArrowRight':
          e.preventDefault();
          await vlc.playback({ time: Math.min(vlc.duration, vlc.time + 10000) });
          break;
        case 'f':
          e.preventDefault();
          toggleFullscreen();
          break;
        case 'm':
          e.preventDefault();
          await vlc.audio({ mute: !vlc.isMuted });
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [vlc]);

  const toggleFullscreen = () => {
    if (!containerRef.current) return;

    if (!document.fullscreenElement) {
      containerRef.current.requestFullscreen();
      setIsFullscreen(true);
    } else {
      document.exitFullscreen();
      setIsFullscreen(false);
    }
  };

  const handleMouseMove = () => {
    setShowControls(true);
  };

  const handleClick = async () => {
    if (!vlc.isInitialized) return;

    if (vlc.playerState === 'playing') {
      await vlc.playback({ action: 'pause' });
    } else if (vlc.playerState === 'stopped' || vlc.playerState === 'ended' || vlc.playerState === 'idle') {
      // If stopped/ended/idle, need to re-open and play
      if (currentItem) {
        await vlc.open(currentItem.Url);
        await vlc.playback({ action: 'play' });
      }
    } else {
      // Paused state - just resume
      await vlc.playback({ action: 'resume' });
    }
  };

  const handleRetry = async () => {
    if (!currentItem) return;
    await vlc.playback({ action: 'stop' });
    await vlc.open(currentItem.Url);
    await vlc.playback({ action: 'play' });
  };

  // No content selected
  if (!currentItem) {
    return (
      <div className="flex items-center justify-center h-full bg-black/90">
        <div className="text-center">
          <Film className="w-16 h-16 mx-auto mb-4 text-muted-foreground" />
          <h3 className="text-2xl font-semibold text-muted-foreground mb-2">
            No content selected
          </h3>
          <p className="text-muted-foreground/60">
            Select something to watch from your library
          </p>
        </div>
      </div>
    );
  }

  return (
    <div
      ref={containerRef}
      className="relative w-full h-full bg-black group"
      onMouseMove={handleMouseMove}
    >
      {/* Video area - VLC child window will be positioned here */}
      <div
        ref={videoAreaRef}
        className="absolute inset-0 z-0"
        onClick={handleClick}
      />

      {/* Overlay container - sits above VLC child window */}
      <div className="absolute inset-0 z-10 pointer-events-none">
        {/* Loading spinner */}
        {(vlc.playerState === 'opening' || vlc.playerState === 'buffering' || state === 'loading') && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/50">
            <Loader2 className="w-16 h-16 text-primary animate-spin" />
          </div>
        )}

        {/* Error message */}
        {vlc.playerState === 'error' && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/90 pointer-events-auto">
            <div className="text-center max-w-lg px-6">
              <AlertTriangle className="w-16 h-16 mx-auto mb-4 text-destructive" />
              <h3 className="text-2xl font-semibold text-destructive mb-2">
                Playback Error
              </h3>
              <p className="text-muted-foreground mb-4">
                {vlc.error || 'Failed to play video stream'}
              </p>

              <Button onClick={handleRetry}>
                Retry
              </Button>

              <p className="text-xs text-muted-foreground/50 font-mono mt-4 truncate max-w-full">
                {currentItem.Url}
              </p>
            </div>
          </div>
        )}

        {/* Track info overlay */}
        {vlc.playerState === 'playing' && vlc.audioTracks.length > 0 && showControls && (
          <div className="absolute top-4 right-4 bg-black/70 rounded-lg px-3 py-2 text-sm pointer-events-auto">
            <div className="text-white/60">
              Audio: {vlc.audioTracks.find(t => t.id === vlc.currentAudioTrack)?.name || 'Default'}
            </div>
            {vlc.subtitleTracks.length > 0 && (
              <div className="text-white/60">
                Subtitle: {vlc.subtitleTracks.find(t => t.id === vlc.currentSubtitleTrack)?.name || 'Off'}
              </div>
            )}
          </div>
        )}

        {/* Controls */}
        {showControls && currentItem && (
          <div className="pointer-events-auto">
            <PlayerControls
              isFullscreen={isFullscreen}
              onToggleFullscreen={toggleFullscreen}
            />
          </div>
        )}
      </div>
    </div>
  );
}

// HTML5 Video Player Implementation
function Html5VideoPlayer() {
  const videoRef = useRef<HTMLVideoElement>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const [showControls, setShowControls] = useState(true);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [retryCount, setRetryCount] = useState(0);
  const [errorMessage, setErrorMessage] = useState<string>('');
  const hideControlsTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const retryTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const {
    currentItem,
    state,
    position,
    volume,
    isMuted,
    setState,
    updatePosition,
    updateDuration,
    play,
  } = usePlayerStore();

  const { getNextEpisode, saveWatchProgress } = useContentStore();
  const { autoPlayNext, defaultVolume, setDefaultVolume, bufferSize } = useSettingsStore();

  // Initialize volume from settings on mount
  useEffect(() => {
    const { setVolume } = usePlayerStore.getState();
    setVolume(defaultVolume);
  }, []);

  // Save volume changes to settings
  useEffect(() => {
    if (volume !== defaultVolume) {
      setDefaultVolume(volume);
    }
  }, [volume, defaultVolume, setDefaultVolume]);

  // Save/restore track preferences
  useEffect(() => {
    const video = videoRef.current;
    if (!video || !currentItem) return;

    const savedTracks = localStorage.getItem('zenith-track-preferences');
    if (savedTracks) {
      try {
        const { audioTrack, subtitleTrack } = JSON.parse(savedTracks);
        if (audioTrack !== undefined) {
          usePlayerStore.getState().setAudioTrack(audioTrack);
        }
        if (subtitleTrack !== undefined) {
          usePlayerStore.getState().setSubtitleTrack(subtitleTrack);
        }
      } catch (e) {
        console.error('Failed to restore track preferences:', e);
      }
    }
  }, [currentItem]);

  // Retry stream function
  const retryStream = () => {
    const video = videoRef.current;
    if (!video || !currentItem) return;

    setRetryCount((prev) => prev + 1);
    setErrorMessage('');
    setState('loading');

    video.load();
    video.play().catch((err) => {
      console.error('Retry failed:', err);
    });
  };

  // Manual retry (reset count)
  const handleManualRetry = () => {
    setRetryCount(0);
    retryStream();
  };

  // Reset retry count when item changes
  useEffect(() => {
    setRetryCount(0);
    setErrorMessage('');

    return () => {
      if (retryTimeoutRef.current) {
        clearTimeout(retryTimeoutRef.current);
      }
    };
  }, [currentItem]);

  // Video event handlers
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const handleLoadedMetadata = () => {
      updateDuration(video.duration);
      setState('playing');
      video.play();
    };

    const handleTimeUpdate = () => {
      updatePosition(video.currentTime);
    };

    const handlePlay = () => setState('playing');
    const handlePause = () => setState('paused');
    const handleWaiting = () => setState('buffering');
    const handleCanPlay = () => {
      if (state === 'buffering') setState('playing');
    };
    const handleEnded = () => {
      setState('idle');

      if (autoPlayNext && currentItem) {
        const nextEpisode = getNextEpisode(currentItem);
        if (nextEpisode) {
          setTimeout(() => play(nextEpisode), 500);
        }
      }
    };
    const handleError = (e: Event) => {
      const mediaError = video.error;
      let message = 'Failed to load stream';

      if (mediaError) {
        switch (mediaError.code) {
          case mediaError.MEDIA_ERR_ABORTED:
            message = 'Stream loading aborted';
            break;
          case mediaError.MEDIA_ERR_NETWORK:
            message = 'Network error - check your connection';
            break;
          case mediaError.MEDIA_ERR_DECODE:
            message = 'Stream format not supported';
            break;
          case mediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
            message = 'Stream source not available';
            break;
        }
      }

      setErrorMessage(message);
      setState('error');

      if (retryCount < 3) {
        const delay = Math.pow(2, retryCount) * 1000;
        retryTimeoutRef.current = setTimeout(() => {
          retryStream();
        }, delay);
      }
    };

    video.addEventListener('loadedmetadata', handleLoadedMetadata);
    video.addEventListener('timeupdate', handleTimeUpdate);
    video.addEventListener('play', handlePlay);
    video.addEventListener('pause', handlePause);
    video.addEventListener('waiting', handleWaiting);
    video.addEventListener('canplay', handleCanPlay);
    video.addEventListener('ended', handleEnded);
    video.addEventListener('error', handleError);

    return () => {
      video.removeEventListener('loadedmetadata', handleLoadedMetadata);
      video.removeEventListener('timeupdate', handleTimeUpdate);
      video.removeEventListener('play', handlePlay);
      video.removeEventListener('pause', handlePause);
      video.removeEventListener('waiting', handleWaiting);
      video.removeEventListener('canplay', handleCanPlay);
      video.removeEventListener('ended', handleEnded);
      video.removeEventListener('error', handleError);
    };
  }, [state, setState, updatePosition, updateDuration, autoPlayNext, currentItem, getNextEpisode, play, retryCount]);

  // Update video source when currentItem changes
  useEffect(() => {
    const video = videoRef.current;
    if (!video || !currentItem) return;

    video.src = currentItem.Url;
    setState('loading');

    if (currentItem.userData?.watchProgress && currentItem.userData.watchProgress > 0) {
      const progressPercent = currentItem.userData.watchProgress;

      video.addEventListener('loadedmetadata', () => {
        const position = (progressPercent / 100) * video.duration;

        if (position > 0 && position < video.duration - 10) {
          video.currentTime = position;
        }
      }, { once: true });
    }
  }, [currentItem, setState]);

  // Update video volume and mute
  useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    video.volume = volume;
    video.muted = isMuted;
  }, [volume, isMuted]);

  // Auto-save watch progress
  useEffect(() => {
    const video = videoRef.current;
    if (!video || !currentItem || state !== 'playing') return;

    const saveInterval = setInterval(async () => {
      if (video.duration > 0) {
        try {
          await saveWatchProgress(currentItem, video.currentTime, video.duration);
        } catch (error) {
          console.error('Failed to save watch progress:', error);
        }
      }
    }, 10000);

    const handlePause = async () => {
      if (video.duration > 0) {
        try {
          await saveWatchProgress(currentItem, video.currentTime, video.duration);
        } catch (error) {
          console.error('Failed to save watch progress:', error);
        }
      }
    };

    video.addEventListener('pause', handlePause);

    return () => {
      clearInterval(saveInterval);
      video.removeEventListener('pause', handlePause);

      if (video.duration > 0) {
        saveWatchProgress(currentItem, video.currentTime, video.duration)
          .catch(err => console.error('Failed to save watch progress on unmount:', err));
      }
    };
  }, [currentItem, state, saveWatchProgress]);

  // Auto-hide controls
  useEffect(() => {
    if (showControls && state === 'playing') {
      if (hideControlsTimeoutRef.current) {
        clearTimeout(hideControlsTimeoutRef.current);
      }

      hideControlsTimeoutRef.current = setTimeout(() => {
        setShowControls(false);
      }, 3000);
    }

    return () => {
      if (hideControlsTimeoutRef.current) {
        clearTimeout(hideControlsTimeoutRef.current);
      }
    };
  }, [showControls, state]);

  // Keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      const video = videoRef.current;
      if (!video) return;

      switch (e.key) {
        case ' ':
        case 'k':
          e.preventDefault();
          video.paused ? video.play() : video.pause();
          break;
        case 'ArrowLeft':
          e.preventDefault();
          video.currentTime = Math.max(0, video.currentTime - 10);
          break;
        case 'ArrowRight':
          e.preventDefault();
          video.currentTime = Math.min(video.duration, video.currentTime + 10);
          break;
        case 'f':
          e.preventDefault();
          toggleFullscreen();
          break;
        case 'm':
          e.preventDefault();
          usePlayerStore.getState().toggleMute();
          break;
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  const toggleFullscreen = () => {
    if (!containerRef.current) return;

    if (!document.fullscreenElement) {
      containerRef.current.requestFullscreen();
      setIsFullscreen(true);
    } else {
      document.exitFullscreen();
      setIsFullscreen(false);
    }
  };

  const handleMouseMove = () => {
    setShowControls(true);
  };

  const handleClick = () => {
    const video = videoRef.current;
    if (video) {
      video.paused ? video.play() : video.pause();
    }
  };

  if (!currentItem) {
    return (
      <div className="flex items-center justify-center h-full bg-black/90">
        <div className="text-center">
          <Film className="w-16 h-16 mx-auto mb-4 text-muted-foreground" />
          <h3 className="text-2xl font-semibold text-muted-foreground mb-2">
            No content selected
          </h3>
          <p className="text-muted-foreground/60">
            Select something to watch from your library
          </p>
        </div>
      </div>
    );
  }

  return (
    <div
      ref={containerRef}
      className="relative w-full h-full bg-black group"
      onMouseMove={handleMouseMove}
    >
      <video
        ref={videoRef}
        className="w-full h-full object-contain cursor-pointer"
        onClick={handleClick}
        preload={bufferSize >= 15 ? 'auto' : 'metadata'}
      />

      {/* Loading spinner */}
      {state === 'loading' && (
        <div className="absolute inset-0 flex items-center justify-center bg-black/50">
          <Loader2 className="w-16 h-16 text-primary animate-spin" />
        </div>
      )}

      {/* Buffering spinner */}
      {state === 'buffering' && (
        <div className="absolute top-4 right-4">
          <Loader2 className="w-8 h-8 text-white animate-spin" />
        </div>
      )}

      {/* Error message */}
      {state === 'error' && (
        <div className="absolute inset-0 flex items-center justify-center bg-black/90">
          <div className="text-center max-w-lg px-6">
            <AlertTriangle className="w-16 h-16 mx-auto mb-4 text-destructive" />
            <h3 className="text-2xl font-semibold text-destructive mb-2">
              Playback Error
            </h3>
            <p className="text-muted-foreground mb-2">
              {errorMessage || 'Failed to load video stream'}
            </p>

            {retryCount > 0 && retryCount < 3 && (
              <p className="text-sm text-muted-foreground mb-4">
                Auto-retrying... (Attempt {retryCount + 1}/3)
              </p>
            )}

            {retryCount >= 3 && (
              <p className="text-sm text-yellow-500 mb-4">
                Maximum retry attempts reached
              </p>
            )}

            <Button onClick={handleManualRetry} className="mt-4">
              Retry Now
            </Button>

            <p className="text-xs text-muted-foreground/50 font-mono mt-4 truncate max-w-full">
              {currentItem.Url}
            </p>
          </div>
        </div>
      )}

      {/* Controls */}
      {showControls && currentItem && (
        <PlayerControls
          isFullscreen={isFullscreen}
          onToggleFullscreen={toggleFullscreen}
        />
      )}
    </div>
  );
}
