/**
 * VLC Player IPC Handlers
 *
 * Handles communication between renderer process and VLC standalone process.
 * Uses VlcProcessManager to communicate with isolated Node.js process.
 */

const { ipcMain } = require('electron');
const { VlcProcessManager } = require('../vlc/vlcProcessManager.js');

let vlcManager = null;

/**
 * Get or create VLC process manager instance (singleton)
 */
async function getVlcManager() {
  if (vlcManager && vlcManager.isReady()) {
    return vlcManager;
  }

  if (!vlcManager) {
    vlcManager = new VlcProcessManager();
  }

  if (!vlcManager.isReady()) {
    await vlcManager.start();
  }

  return vlcManager;
}

/**
 * Register VLC IPC handlers
 */
function registerVlcHandlers(mainWindow) {
  console.log('[VLC] Registering IPC handlers');

  // Check if VLC is available
  ipcMain.handle('vlc:isAvailable', async () => {
    try {
      const manager = await getVlcManager();
      // Try to initialize to verify it works
      await manager.call('init');
      return true;
    } catch (error) {
      console.error('[VLC] Availability check failed:', error);
      return false;
    }
  });

  // Initialize player and setup event forwarding
  ipcMain.handle('vlc:init', async () => {
    try {
      const manager = await getVlcManager();

      // Initialize player in standalone process
      await manager.call('init');

      // Setup event forwarding to renderer
      manager.on('timeChanged', (time) => {
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('vlc:timeChanged', time);
        }
      });

      manager.on('stateChanged', (state) => {
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('vlc:stateChanged', state);
        }
      });

      manager.on('endReached', () => {
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('vlc:endReached');
        }
      });

      manager.on('error', (message) => {
        if (mainWindow && !mainWindow.isDestroyed()) {
          mainWindow.webContents.send('vlc:error', message);
        }
      });

      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  });

  // Create child window for VLC rendering
  // Create standalone VLC window
  ipcMain.handle('vlc:createChildWindow', async (_, x, y, width, height) => {
    console.log('[VLC] createChildWindow called with:', { x, y, width, height });

    try {
      const manager = await getVlcManager();

      // Call createWindow on standalone process
      // Parent handle is always 0 (standalone window, not embedded)
      const result = await manager.call('createWindow', x, y, width, height);

      console.log('[VLC] Standalone window created:', result);
      return { success: result };
    } catch (error) {
      console.error('[VLC] CreateChildWindow error:', error);
      return { success: false, error: error.message };
    }
  });

  // Destroy child window
  ipcMain.handle('vlc:destroyChildWindow', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return { success: false };

    try {
      const result = vlcPlayer.destroyChildWindow();
      return { success: result };
    } catch (error) {
      console.error('[VLC] DestroyChildWindow error:', error);
      return { success: false, error: error.message };
    }
  });

  // Update window bounds (for position/size sync)
  ipcMain.handle('vlc:setBounds', async (_, x, y, width, height) => {
    try {
      const manager = await getVlcManager();
      return await manager.call('setBounds', x, y, width, height);
    } catch (error) {
      console.error('[VLC] SetBounds error:', error);
      return false;
    }
  });

  // Show child window
  ipcMain.handle('vlc:showWindow', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return false;

    try {
      return vlcPlayer.showWindow();
    } catch (error) {
      console.error('[VLC] ShowWindow error:', error);
      return false;
    }
  });

  // Hide child window
  ipcMain.handle('vlc:hideWindow', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return false;

    try {
      return vlcPlayer.hideWindow();
    } catch (error) {
      console.error('[VLC] HideWindow error:', error);
      return false;
    }
  });

  // Playback control
  ipcMain.handle('vlc:play', async (_, url) => {
    try {
      const manager = await getVlcManager();
      return await manager.call('play', url);
    } catch (error) {
      console.error('[VLC] Play error:', error);
      return false;
    }
  });

  ipcMain.handle('vlc:pause', async () => {
    try {
      const manager = await getVlcManager();
      await manager.call('pause');
    } catch (error) {
      console.error('[VLC] Pause error:', error);
    }
  });

  ipcMain.handle('vlc:resume', async () => {
    try {
      const manager = await getVlcManager();
      // VLC doesn't have separate resume, just call pause again to toggle
      await manager.call('pause');
    } catch (error) {
      console.error('[VLC] Resume error:', error);
    }
  });

  ipcMain.handle('vlc:stop', async () => {
    try {
      const manager = await getVlcManager();
      await manager.call('stop');
    } catch (error) {
      console.error('[VLC] Stop error:', error);
    }
  });

  ipcMain.handle('vlc:seek', async (_, time) => {
    try {
      const manager = await getVlcManager();
      await manager.call('seek', time);
    } catch (error) {
      console.error('[VLC] Seek error:', error);
    }
  });

  // Volume control
  ipcMain.handle('vlc:setVolume', async (_, volume) => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return;

    try {
      vlcPlayer.setVolume(volume);
    } catch (error) {
      console.error('[VLC] SetVolume error:', error);
    }
  });

  ipcMain.handle('vlc:getVolume', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return 0;

    try {
      return vlcPlayer.getVolume();
    } catch (error) {
      console.error('[VLC] GetVolume error:', error);
      return 0;
    }
  });

  ipcMain.handle('vlc:setMute', async (_, mute) => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return;

    try {
      vlcPlayer.setMute(mute);
    } catch (error) {
      console.error('[VLC] SetMute error:', error);
    }
  });

  ipcMain.handle('vlc:getMute', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return false;

    try {
      return vlcPlayer.getMute();
    } catch (error) {
      console.error('[VLC] GetMute error:', error);
      return false;
    }
  });

  // Time/Position
  ipcMain.handle('vlc:getTime', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return 0;

    try {
      return vlcPlayer.getTime();
    } catch (error) {
      return 0;
    }
  });

  ipcMain.handle('vlc:getLength', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return 0;

    try {
      return vlcPlayer.getLength();
    } catch (error) {
      return 0;
    }
  });

  ipcMain.handle('vlc:getPosition', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return 0;

    try {
      return vlcPlayer.getPosition();
    } catch (error) {
      return 0;
    }
  });

  ipcMain.handle('vlc:setPosition', async (_, position) => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return;

    try {
      vlcPlayer.setPosition(position);
    } catch (error) {
      console.error('[VLC] SetPosition error:', error);
    }
  });

  // State
  ipcMain.handle('vlc:getState', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return 'idle';

    try {
      return vlcPlayer.getState();
    } catch (error) {
      return 'error';
    }
  });

  ipcMain.handle('vlc:isPlaying', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return false;

    try {
      return vlcPlayer.isPlaying();
    } catch (error) {
      return false;
    }
  });

  ipcMain.handle('vlc:isSeekable', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return false;

    try {
      return vlcPlayer.isSeekable();
    } catch (error) {
      return false;
    }
  });

  // Audio tracks
  ipcMain.handle('vlc:getAudioTracks', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return [];

    try {
      return vlcPlayer.getAudioTracks();
    } catch (error) {
      return [];
    }
  });

  ipcMain.handle('vlc:getAudioTrack', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return -1;

    try {
      return vlcPlayer.getAudioTrack();
    } catch (error) {
      return -1;
    }
  });

  ipcMain.handle('vlc:setAudioTrack', async (_, trackId) => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return false;

    try {
      return vlcPlayer.setAudioTrack(trackId);
    } catch (error) {
      console.error('[VLC] SetAudioTrack error:', error);
      return false;
    }
  });

  // Subtitle tracks
  ipcMain.handle('vlc:getSubtitleTracks', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return [];

    try {
      return vlcPlayer.getSubtitleTracks();
    } catch (error) {
      return [];
    }
  });

  ipcMain.handle('vlc:getSubtitleTrack', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return -1;

    try {
      return vlcPlayer.getSubtitleTrack();
    } catch (error) {
      return -1;
    }
  });

  ipcMain.handle('vlc:setSubtitleTrack', async (_, trackId) => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return false;

    try {
      return vlcPlayer.setSubtitleTrack(trackId);
    } catch (error) {
      console.error('[VLC] SetSubtitleTrack error:', error);
      return false;
    }
  });

  ipcMain.handle('vlc:setSubtitleDelay', async (_, delay) => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return false;

    try {
      return vlcPlayer.setSubtitleDelay(delay);
    } catch (error) {
      console.error('[VLC] SetSubtitleDelay error:', error);
      return false;
    }
  });

  // Video tracks
  ipcMain.handle('vlc:getVideoTracks', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return [];

    try {
      return vlcPlayer.getVideoTracks();
    } catch (error) {
      return [];
    }
  });

  // Playback rate
  ipcMain.handle('vlc:setRate', async (_, rate) => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return;

    try {
      vlcPlayer.setRate(rate);
    } catch (error) {
      console.error('[VLC] SetRate error:', error);
    }
  });

  ipcMain.handle('vlc:getRate', async () => {
    const vlcPlayer = getPlayer();
    if (!vlcPlayer) return 1.0;

    try {
      return vlcPlayer.getRate();
    } catch (error) {
      return 1.0;
    }
  });

  console.log('[VLC] IPC handlers registered');
}

/**
 * Cleanup VLC resources
 */
async function cleanupVlc() {
  if (vlcManager) {
    console.log('[VLC] Cleaning up VLC process...');
    try {
      await vlcManager.stop();
    } catch (error) {
      console.error('[VLC] Cleanup error:', error);
    }
    vlcManager = null;
  }
}

module.exports = {
  registerVlcHandlers,
  cleanupVlc,
};
